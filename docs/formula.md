# Формула обработки пользовательского ввода

Разберём формулу максимально глубоко — математически, геометрически и с точки зрения UX.

Вот ядро:

```
min + round((value - min) / step) * step
```

Это приведение произвольного числа к ближайшей точке сетки шагов.

## Исходный код

```ts
export function normalizeToStep(
  value: Decimal,
  min: Decimal,
  max: Decimal,
  step: Decimal
): Decimal {
  const clamped = clampDecimal(value, min, max);

  const normalized = min.plus(
    clamped.minus(min).div(step).round().times(step)
  );

  if (normalized.gt(max)) {
    const floorSteps = max.minus(min).div(step).floor();
    const floorValue = min.plus(floorSteps.times(step));

    return clamped.minus(max).abs().lte(clamped.minus(floorValue).abs())
      ? max
      : floorValue;
  }

  if (normalized.lt(min)) {
    return min;
  }

  return normalized;
}
```

---

## 1. Что вообще делает функция?

Она делает две вещи:

- Ограничивает значение диапазоном `[min, max]`
- Приводит его к ближайшему допустимому значению по шагу `step`

Это называется **snap to step grid**.

---

## 2. Визуальная интуиция

Представь числовую ось:

```
min ----|----|----|----|---- max
             ↑    ↑    ↑
           сетка шагов
```

Если:

```
min  = 10
step = 3
```

Точки сетки: `10, 13, 16, 19, 22, 25, ...`

| Ввод пользователя | Ближайшая точка сетки |
|:-----------------:|:---------------------:|
| `17`              | `16`                  |
| `18`              | `19`                  |

---

## 3. Почему формула именно такая?

Разберём по частям.

### Шаг 1 — смещение в локальную систему координат

```
(value - min)
```

Потому что сетка начинается от `min`, а не от `0`.

```
min = 10, value = 17
17 - 10 = 7
```

Теперь считаем шаги от `0`.

### Шаг 2 — делим на шаг

```
(value - min) / step
```

Это отвечает на вопрос: **сколько шагов от `min` до `value`?**

```
7 / 3 = 2.333...
```

### Шаг 3 — округляем

```
round(2.333) = 2
```

Это выбор ближайшей точки сетки. Если бы было `2.6` → округлилось бы до `3`.

### Шаг 4 — возвращаемся в масштаб значений

```
2 * 3 = 6
```

### Шаг 5 — возвращаем смещение `min`

```
10 + 6 = 16
```

### Итог

> Возьми количество шагов от `min` до `value`, округли до ближайшего целого, и пересчитай обратно.

---

## 4. Почему нельзя просто `round(value / step) * step`?

Потому что сетка начинается **не от `0`**, а от `min`.

```
min = 10, step = 3
```

| Система координат | Точки сетки        |
|:-----------------:|:------------------:|
| от `0`            | `0, 3, 6, 9, 12, 15, 18` |
| от `min`          | `10, 13, 16, 19`   |

Это разные системы координат.

---

## 5. Почему сначала `clamp`?

```ts
const clamped = clampDecimal(value, min, max);
```

Чтобы гарантировать: `value ∈ [min, max]`.

Без этого `snap` мог бы:

- уйти ниже `min`
- или выше `max`

---

## 6. Особый случай — `max` может не лежать на сетке

> Both `min` and `max` are always valid snap targets, even when `max` doesn't fall exactly on the step grid starting from `min`.

**Пример:**

```
min = 0, step = 3, max = 10
```

Сетка: `0, 3, 6, 9, 12` — но `10` **не на сетке**.

Если пользователь введёт `10`:

```
(10 - 0) / 3 = 3.333
round = 3
3 * 3 = 9
```

Получится `9` — хотя пользователь явно выбрал `max`. Это некорректно с точки зрения UX.

---

## 7. Что делает блок `if (normalized.gt(max))`?

Он ловит случай, когда после округления получилось число `> max`.

**Пример:**

```
min = 0, step = 3, max = 10, value = 9.8

(9.8 / 3) = 3.266 → round = 3 → 3 * 3 = 9  ✓
```

Но если `value = 10`:

```
(10 / 3) = 3.333 → round = 3 → 9  ✗ (max не будет достигнут)
```

Тогда код делает:

```ts
floorSteps = floor((max - min) / step)  // floor(10 / 3) = 3
floorValue = min + floorSteps * step    // 0 + 9 = 9
```

Затем сравнивает, что **ближе** к исходному `clamped`:

```
abs(clamped - max)       // расстояние до max
abs(clamped - floorValue) // расстояние до ближайшей точки сетки
```

Если ближе к `max` → вернуть `max`.

---

## 8. Геометрическая интерпретация

Функция делает **проецирование на дискретную сетку**, но с добавлением ручной вершины `max`.

Это по сути **округление к ближайшей точке множества**:

```
S = { min + k*step } ∪ { max }
```

---

## 9. Почему `round`, а не `floor`?

| Функция | Поведение          |
|:-------:|:------------------:|
| `floor` | всегда вниз        |
| `ceil`  | всегда вверх       |
| `round` | к ближайшему ✓     |

`round` — математически корректный snap.

---

## 10. Почему `Decimal` здесь критичен

Если бы использовался обычный `float`:

```
(value - min) / step  →  2.9999999998
```

И `round` дал бы `3` вместо `2`.

`Decimal` гарантирует:

- точное деление
- корректное округление

---

## 11. Полная математическая формализация

Функция реализует:

$$\text{argmin}_{x \in S} \, |x - \text{value}|$$

Где:

$$S = \{ \text{min} + k \cdot \text{step} \} \cap [\text{min},\, \text{max}] \cup \{\text{max}\}$$

То есть: **найти ближайшую допустимую точку**. Это чистая дискретная оптимизация.

---

## 12. Почему есть проверка `normalized.lt(min)`?

Теоретически `round` может дать `-1` шаг, особенно если `value < min`. Это страховка от артефактов округления.

---

## Итог

```
min + round((value - min) / step) * step
```

Формула состоит из трёх этапов:

1. **Переход в систему координат шага** — `(value - min)`
2. **Округление** — `round(.../ step)`
3. **Возврат в абсолютную систему** — `min + ... * step`

Дополнительные условия:

- гарантируют `max` как валидную вершину
- защищают от артефактов округления
